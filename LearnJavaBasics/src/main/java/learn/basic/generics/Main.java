package learn.basic.generics;

import learn.basic.generics.helper.beans.Bike;
import learn.basic.generics.helper.beans.Car;
import learn.basic.generics.helper.beans.Vehicle;
import learn.basic.generics.stack.FlexibleGenericStack;

import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String args[]) {

        // 1.
        /*
        GenericStack rawParameterizedGenericStack = new GenericStack<>(30); // e.g. List is raw paremterized, List<Integer> is not raw
        rawParameterizedGenericStack.push(1);
        rawParameterizedGenericStack.push(2);
        rawParameterizedGenericStack.push("yes");


        // doesn't work unless you add a type cast to int or String or whatever, except object
        int someInt = rawParameterizedGenericStack.pop();
        String someString = rawParameterizedGenericStack.pop();

//        this will work
//        so raw Parametrized object is equivatent to Object type, i.e. it can store anything,
//        But, don't use it coz you'll not know what is the actual type of the element in the list
//        at a particular index. This can lead to runtime Exceptions, that can be hard to debug.
         Object obj = rawParameterizedGenericStack.pop();
         */

        /*----------------------------------------------------------------------------------------------*/

        // 2.
        /*
            Generic with parameters
            Better but not perfect
            The following code compiles and runs alright
         */

        /*
        GenericStack<Car> carGenericStack = new GenericStack<>(2);
        GenericStack<Bike> bikeGenericStack = new GenericStack<>(2);
        carGenericStack.push(new Car());
        bikeGenericStack.push(new Bike());
        carGenericStack.push(new Car());
        bikeGenericStack.push(new Bike());

        Vehicle genericVehicle1 = carGenericStack.pop();
        Vehicle genericVehicle2 = bikeGenericStack.pop();
        genericVehicle1.run(); // runs fine
        System.out.println(genericVehicle1.profit());
        genericVehicle2.run(); // runs fine
        System.out.println(genericVehicle2.profit());


//        But what we want is to combine all vehicles sold by the company in a list to calculate
//        the overall profit generated by the sales of all the vehicles.
        List<Bike> bikeList = List.of(new Bike(), new Bike());
        List<Car> carList = List.of(new Car(), new Car());

        GenericStack<Vehicle> vehicleGenericStack = new GenericStack<>(4);


        // Even though Bike & Car extend vehicles, they can't be pushed into Stack<Vehicle>
        // That's bcoz Stack<Car> is not a subtype of Stack<Vehicle>
        // This sounds wrong, but that's how it is
        vehicleGenericStack.pushAll(bikeList);
        vehicleGenericStack.pushAll(carList);

        // the following will also not work for the same reason
        List<Vehicle> allSoldVehicles = new ArrayList<>();
        GenericStack<Car> anotherCarGenericStack = new GenericStack<>(2);
        anotherCarGenericStack.popAll(allSoldVehicles);

        // The following will work however, but we should be able to do both
        // We need to make the Stack more flexible
        vehicleGenericStack.push(new Bike());
         */

        /*----------------------------------------------------------------------------------------------*/

        // 3. Flexible Generics

        /*
            Howerver, if you use bounded wildcards when using generic Producers & Consumers
            you can make your generic code more flexible, as in FlexibleGenericStack.class(see pushall & popall)

            However, don't use bounded wildcards if the object is not purely either a producer or a consumer.
            If the object is both prod & cons, then use regular specific(less flexible) generics

            Note: List<T> arguments in pushall is a producer & in popall is a consumer
         */

        List<Bike> bikeList = List.of(new Bike(), new Bike());
        List<Car> carList = List.of(new Car(), new Car());

        FlexibleGenericStack<Vehicle> flexibleGenericStack = new FlexibleGenericStack<>(5);

        // works
        flexibleGenericStack.pushAll(bikeList);
        flexibleGenericStack.pushAll(carList);

        // the following will also work
        List<Vehicle> allSoldVehicles = new ArrayList<>();
        FlexibleGenericStack<Car> anotherFlexibleGenericStack = new FlexibleGenericStack<>(2);
        anotherFlexibleGenericStack.popAll(allSoldVehicles);

        // this will work too
        flexibleGenericStack.push(new Bike());

        System.out.println(flexibleGenericStack.toString());
    }
}
